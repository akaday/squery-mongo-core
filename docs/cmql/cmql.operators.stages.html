<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>cmql.operators.stages documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Cmql</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cmql</span></div></div></li><li class="depth-2 branch"><a href="cmql.administration.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>administration</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>common</span></div></div></li><li class="depth-3"><a href="cmql.common.common.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>common</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>convert</span></div></div></li><li class="depth-3 branch"><a href="cmql.convert.commands.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>commands</span></div></a></li><li class="depth-3 branch"><a href="cmql.convert.common.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>common</span></div></a></li><li class="depth-3 branch"><a href="cmql.convert.js-functions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>js-functions</span></div></a></li><li class="depth-3 branch"><a href="cmql.convert.operators.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>operators</span></div></a></li><li class="depth-3"><a href="cmql.convert.stages.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stages</span></div></a></li><li class="depth-2 branch"><a href="cmql.diagnostic.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>diagnostic</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>operators</span></div></div></li><li class="depth-3 branch"><a href="cmql.operators.operators.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>operators</span></div></a></li><li class="depth-3 branch"><a href="cmql.operators.options.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>options</span></div></a></li><li class="depth-3 current"><a href="cmql.operators.stages.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stages</span></div></a></li><li class="depth-2 branch"><a href="cmql.read-write.html"><div class="inner"><span class="tree" style="top: -114px;"><span class="top" style="height: 123px;"></span><span class="bottom"></span></span><span>read-write</span></div></a></li><li class="depth-2 branch"><a href="cmql.roles.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>roles</span></div></a></li><li class="depth-2"><a href="cmql.users.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>users</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="cmql.operators.stages.html#var-add"><div class="inner"><span>add</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-add-to-root"><div class="inner"><span>add-to-root</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-bucket"><div class="inner"><span>bucket</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-bucket-auto"><div class="inner"><span>bucket-auto</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-coll-stats-s"><div class="inner"><span>coll-stats-s</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-count-s"><div class="inner"><span>count-s</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-current-op-s"><div class="inner"><span>current-op-s</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-facet"><div class="inner"><span>facet</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-graphlookup"><div class="inner"><span>graphlookup</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-group"><div class="inner"><span>group</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-group-array"><div class="inner"><span>group-array</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-group-count"><div class="inner"><span>group-count</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-group-count-sort"><div class="inner"><span>group-count-sort</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-if-match"><div class="inner"><span>if-match</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-join"><div class="inner"><span>join</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-limit"><div class="inner"><span>limit</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-list-local-sessions"><div class="inner"><span>list-local-sessions</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-lookup"><div class="inner"><span>lookup</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-lookup-p"><div class="inner"><span>lookup-p</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-match"><div class="inner"><span>match</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-merge-s"><div class="inner"><span>merge-s</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-move-to-root"><div class="inner"><span>move-to-root</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-out"><div class="inner"><span>out</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-pipeline"><div class="inner"><span>pipeline</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-project"><div class="inner"><span>project</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-redact"><div class="inner"><span>redact</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-reduce-array"><div class="inner"><span>reduce-array</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-replace-root"><div class="inner"><span>replace-root</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-replace-with"><div class="inner"><span>replace-with</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-sample"><div class="inner"><span>sample</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-set-s"><div class="inner"><span>set-s</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-skip"><div class="inner"><span>skip</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-sort"><div class="inner"><span>sort</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-union-s"><div class="inner"><span>union-s</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-unset"><div class="inner"><span>unset</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-unwind"><div class="inner"><span>unwind</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-unwind-add-to-root"><div class="inner"><span>unwind-add-to-root</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-unwind-move-to-root"><div class="inner"><span>unwind-move-to-root</span></div></a></li><li class="depth-1"><a href="cmql.operators.stages.html#var-unwind-replace-root"><div class="inner"><span>unwind-replace-root</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">cmql.operators.stages</h1><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-add"><h3>add</h3><div class="usage"><code>(add &amp; fields)</code></div><div class="doc"><pre class="plaintext">$addFields
No need to type add in cmql
A Map literal as a pipeline stage means add
The only situation that is useful is if the new field has the name
of an option in the command.
For example
{:allowDiskUse true} will be interpeted as option not as add-field
Dont use a variable that was added in the same add,use separate add
Call
{:field1 .. :field2 .. :!field3 ...}
The last one !field3 means replace the field3 if it existed
This happens anyways but not always (for example add doc on doc =&gt; merge)
Using :!field3 i know that i will replace it</pre></div></div><div class="public anchor" id="var-add-to-root"><h3>add-to-root</h3><div class="usage"><code>(add-to-root e-doc)</code></div><div class="doc"><pre class="plaintext">newRoot = merge(root+doc)+doc_field
Embeded document is added to the document
and remains embeded.
{:field1 {:field2 value2}}
(add-to-root :field1)-&gt;
{:field1 {:field2 value2}
 :field2 value2}</pre></div></div><div class="public anchor" id="var-bucket"><h3>bucket</h3><div class="usage"><code>(bucket group-id-field boundaries &amp; args)</code></div><div class="doc"><pre class="plaintext">$bucket
group =&gt; all members of the group have the same 1 value
          on the grouping field/fields
bucket =&gt; all members of the group have value in a range
          of allowed values
bucket allows you to define groups on range of values
(same range=&gt;same group) (bucket groups)
[0,18,30,40,60]  buckets =&gt;  [0,18) [18,30) [30,40) [40,60)
&amp; args = default(optional,bucket name for those out of range,
                 if not provided,and out of range =&gt; error)
accumulators(optional) 1 doc with all the acculumators inside</pre></div></div><div class="public anchor" id="var-bucket-auto"><h3>bucket-auto</h3><div class="usage"><code>(bucket-auto group-id-field buckets-number &amp; args)</code></div><div class="doc"><pre class="plaintext">$bucketAuto
same as bucket,but now i give just the number of buckets
that i want and mongo tries to find the right ranges,
so each bucket has the same number of members as possible
group =&gt; all members of the group have the same 1 value
         on the grouping field/fields
bucket =&gt; the number of buckets that mongo will auto-make
&amp; args = granularity(optional,a string,picking the way to make the ranges,
         for example granularity='POWERSOF2' see docs)
Accumulators(optional) 1 doc with all the acculumators inside</pre></div></div><div class="public anchor" id="var-coll-stats-s"><h3>coll-stats-s</h3><div class="usage"><code>(coll-stats-s options-map)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-count-s"><h3>count-s</h3><div class="usage"><code>(count-s ref-e)</code><code>(count-s)</code></div><div class="doc"><pre class="plaintext">$count
Counts all documents in collection its equivalent with
(group nil {:count (sum- 1)})</pre></div></div><div class="public anchor" id="var-current-op-s"><h3>current-op-s</h3><div class="usage"><code>(current-op-s options-map)</code></div><div class="doc"><pre class="plaintext">{ $currentOp: { allUsers: &lt;boolean&gt;, idleConnections: &lt;boolean&gt;, idleCursors: &lt;boolean&gt;, idleSessions: &lt;boolean&gt;, localOps: &lt;boolean&gt; } }
</pre></div></div><div class="public anchor" id="var-facet"><h3>facet</h3><div class="usage"><code>(facet &amp; fields)</code></div><div class="doc"><pre class="plaintext">$facet
Run many pipelines in serial using as source the same pipeline
Call
(q ...
    ...
    (facet {:f1 pipeline1
            :f2 pipeline2})
The result is one document with ONLY the fields :f1 :f2
f1,f2 will be arrays with the document results of each pipeline
Restrictions
 I cant use those stages in facet pipelines
 collStats/facet/geoNear/indexStats/out/merge/planCacheStats</pre></div></div><div class="public anchor" id="var-graphlookup"><h3>graphlookup</h3><div class="usage"><code>(graphlookup collection startWith connectFromField connectToField as maxDepth depthField restrictSearchWithMatch)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-group"><h3>group</h3><div class="usage"><code>(group e &amp; accumulators)</code></div><div class="doc"><pre class="plaintext">$group
Groups in 1 document,using accumulators
 e = nil      meaning {:_id nil} +remove the :_id field after
   = :field   meaning {:_id :field} + rename after the :_id to :field
      For more than 1 fields use edoc like
        {:_id {:fiedl1 .. :field2 .. ...}}
   = {:_id edoc/field/nil} like mongo original group
   = {:field edoc/field/nil} like mongo original group + rename :_id to :field
Acumulators one or many like (sum- :field) or (avg- :field) .... </pre></div></div><div class="public anchor" id="var-group-array"><h3>group-array</h3><div class="usage"><code>(group-array array-ref group-field accumulators results-field)</code><code>(group-array array-ref accumulators results-field)</code></div><div class="doc"><pre class="plaintext">Used to reduce an array to another array,because conj- is very slow
Very fast uses lookup with pipepline facet,and group
Requires a dummy collection with 1 document set in settings
Stage operator ,results are added to the root document
For nested arrays,results must be moved to that position manually
Call
(group-array :myarray  ;; the ref of the array i want to group
             {:myagg1 (conj-each- :myarray) ;; reuse of the :myarray name
              :myagg2 (sum- :myarray)}
             :mygroups)
Result
{
 ...old_fields...
 :mygroups [{:myarray id1 :myagg1 ... :myagg2 ...} {:myarray id2 :myagg1 ... :myagg2 ...}]
}</pre></div></div><div class="public anchor" id="var-group-count"><h3>group-count</h3><div class="usage"><code>(group-count e)</code></div><div class="doc"><pre class="plaintext">$group
(group e {'count' {'$sum' 1}})
used for simplicity because common</pre></div></div><div class="public anchor" id="var-group-count-sort"><h3>group-count-sort</h3><div class="usage"><code>(group-count-sort e desc?)</code></div><div class="doc"><pre class="plaintext">group by e
{:count {$sum 1}}
sort by :!count(desc?true) or :count
</pre></div></div><div class="public anchor" id="var-if-match"><h3>if-match</h3><div class="usage"><code>(if-match fields let-or-when-matched when-not-matched)</code></div><div class="doc"><pre class="plaintext">$merge
Helper used only as argument in merge</pre></div></div><div class="public anchor" id="var-join"><h3>join</h3><div class="usage"><code>(join localfield foreign-table-field)</code><code>(join foreign-table-field)</code></div><div class="doc"><pre class="plaintext">$sql_join
Like sql join,join when equal on field,replace left document with
the merged document
Call
(join :localfield :foreignTable.foreingfField)
(join :foreignTable.foreingfField)
  assumes localfield name to be foreingField name </pre></div></div><div class="public anchor" id="var-limit"><h3>limit</h3><div class="usage"><code>(limit n)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-list-local-sessions"><h3>list-local-sessions</h3><div class="usage"><code>(list-local-sessions users-map)</code><code>(list-local-sessions)</code></div><div class="doc"><pre class="plaintext">users-map = {} or { allUsers: true } or { users: [ { user: &lt;user&gt;, db: &lt;db&gt; }, ... ] } 
</pre></div></div><div class="public anchor" id="var-lookup"><h3>lookup</h3><div class="usage"><code>(lookup localfield foreign-table-field join-result-field)</code></div><div class="doc"><pre class="plaintext">$lookup
Left equality join
doc= {'a' 'b' 'c' 'd'}
doc result (the one from the left,the doc i had in pipeline)
{'a' 'b' 'c' 'd' :joined [joined_doc1 joined_doc2 ...]}
The joined_doc has is like merge of the 2 joined docs
The joined field is created even if empty array (zero joined)
The joined fields can be an array, in this case we get an array with the joined. (like join each member)
Call
(lookip :a :coll2.e :joined) ; join if :a==:e</pre></div></div><div class="public anchor" id="var-lookup-p"><h3>lookup-p</h3><div class="usage"><code>(lookup-p foreign-coll-name let-vars pipeline join-result-field)</code><code>(lookup-p foreign-coll-name pipeline join-result-field)</code></div><div class="doc"><pre class="plaintext">$lookup
lookup with pipeline to allow more join creteria(not just equality on 2 field)
also the pipeline allows the joined doc to have any shape (not just merge)
Returns like lookup
{'a' 'b' 'c' 'd' :joined [joined_doc1 joined_doc2 ...]}
:joined is an array with the result of the pipeline
inside the pipeline references refer to the right doc
to refer to the left doc from pipeline use variables
Using variables and coll2 references i make complex join creteria
and withe the pipeline i can make the joined docs to have any shape
Call
(lookup :coll2
        [:v1- :afield ...] ; optional
        [stage1
         stage2]
        :joined)</pre></div></div><div class="public anchor" id="var-match"><h3>match</h3><div class="usage"><code>(match e-doc)</code></div><div class="doc"><pre class="plaintext">$match
No need to use it in cmql unless you want to use Query operators
cmql auto-generates a match stage from filters if one after another,
auto-combine them with $expr $and
Call
(q ....
   (=_ :age 25)
   (&gt;_ :weight 50))
Call (if we want to use a query operator)
(match { views: { '$gte' 1000 }})</pre></div></div><div class="public anchor" id="var-merge-s"><h3>merge-s</h3><div class="usage"><code>(merge-s db-namespace if-match-e)</code><code>(merge-s coll-namespace)</code></div><div class="doc"><pre class="plaintext">$merge
Update/upsert one collection,using what its coming from the pipeline.
Merge in document level and collection level.
Join when i want mathcing  parts from other collection.
Merge when i want from both collections ,even if not match.
collection -&gt; pipeline -&gt; collection   (normal updates)
any_pipeline -&gt; collection             (merge)
For example keepExisting means keep what collection had
Updates that collection,and returns nothing(an empty cursor)
Requeries a unique index in the right collection,on the merged fields

3 call ways
(merge :mydb.mycoll)

(merge :mydb.mycoll                ;;no variables used
       (if-match [field1 fied2]    ;;becomes  :on [field1 field2]
         whenMatched            ;;can also be pipeline
         whenNoMatched))

(merge :mydb.mycoll
       (if-match [field1 fied2]
         (let- [:v1- :f1 :v2- :f2 ...] ; to refer pipeline doc fields
           whenMatched     ;;can also be pipeline
           whenNoMatced)))

whenMatched
 replace      (keep pipelines)
 keepExisting (keep collections)
 merge   (merge old+new document ,like mergeObjects)
 fail    (stops in the middle if happen,no rollback)
 pipeline(used like update pipepline =&gt;,i can use only
          $addFields=$set  $project=$unset $replaceRoot=$replaceWith)

whenNotMatched
 insert  (insert pipelines)
 discard (ignore pipelines)
 fail (if pipeline has ane not match fail,but no rollback)</pre></div></div><div class="public anchor" id="var-move-to-root"><h3>move-to-root</h3><div class="usage"><code>(move-to-root e-doc)</code></div><div class="doc"><pre class="plaintext">newRoot=merge(root+doc)-doc_field
Add to root,and remove the embeded doc =&gt;as if it moved to root</pre></div></div><div class="public anchor" id="var-out"><h3>out</h3><div class="usage"><code>(out db-namespace)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-pipeline"><h3>pipeline</h3><div class="usage"><code>(pipeline &amp; args)</code></div><div class="doc"><pre class="plaintext">(pipeline stage1 stage2 ..) = [stage1 stage2 ...]
Used optionally to avoid confusion</pre></div></div><div class="public anchor" id="var-project"><h3>project</h3><div class="usage"><code>(project &amp; fields)</code></div><div class="doc"><pre class="plaintext">$project
In cmql [...] inside a pipeline is a project stage(except nested stages)
{:f 1} means {:f (literal- 1)} so don't use it for project inside []
If you want to use this notation use MQL directly {'$project' ....}
Call
1)add those that i want to keep(and optionally :!_id to remove it
  [:!_id :f1 {:f3 (+_ :a 1)} {:!f4 (*_ :a 1))}] (all others wil be removed)
  {:!f4 ..} means replace the old f4
  (replace happens anyways(without {:! ..}) but not always)
2)add those that i want to remove
  [:!a :!b]         (all others will be kept)
*i never mix keep/remove except :!_id</pre></div></div><div class="public anchor" id="var-redact"><h3>redact</h3><div class="usage"><code>(redact condition-DESCEND-PRUNE-KEEP)</code></div><div class="doc"><pre class="plaintext">$redact
I keep or delete root document,or embeded documents based on condition
instead of doing it by hand and paths,like auto-find all embeded documents
stage =&gt; argument = 1 doc from the pipeline
i start at level 0 {field0 {field1 {field2 ..}}}
if condition $$DESCEND/$$PRUNE/$$KEEP
else $$DESCEND/$$PRUNE/$$KEEP

if $$PRUNE i delete that document and everything inside
if $$KEEP i keep that documents and everything inside
if $$DESCEND i keep the document,but i re-run the condition
  in the next level,in my case i repeat on {field1 {field2 ..}}

$$DESCEND allows to check all levels so when done,i know that
all the documents remained satisfy the condition
(no matter the embed level they are)

Arg
any expression that evaluates to the 3 system variables,
normaly its a condition using field references
(if i use references and descend i have to make sure they that
 they exist in all embeded documents or check inside the condition
 what to do when they dont exist)
$$DESCEND (keep embeded document,but search seperatly the embeded ones?)
$$PRUNE   (remove embeded document,dont search more at this level?)
$$KEEP    (keep embeded document,dont search embeded ones?)</pre></div></div><div class="public anchor" id="var-reduce-array"><h3>reduce-array</h3><div class="usage"><code>(reduce-array array-ref accumulators)</code></div><div class="doc"><pre class="plaintext">Used to reduce an array to another array,because conj- is very slow
Very fast uses lookup with pipepline facet,and group
Requires a dummy collection with 1 document set in settings
Stage operator ,results are added to the root document
For nested arrays,results must be moved to that position manually
Call
(group-array :myarray   ;; the ref of the array i want to reduce
             {:myagg1 (conj-each- :myarray) ;; reuse of the :myarray ref
             :myagg2 (sum- :myarray)})
Result(i can add group-field and be like below,but not useful if no group)
{
 ...old_fields...
 :myagg1 .....
 :myagg2 .....
 }</pre></div></div><div class="public anchor" id="var-replace-root"><h3>replace-root</h3><div class="usage"><code>(replace-root e-doc)</code></div><div class="doc"><pre class="plaintext">$replaceRoot
Embeded document fully replaces the document including the :_id
Call
doc={:field1 {:field2 value2}}
(replace-root :field1)
outdoc={:field2 value2}</pre></div></div><div class="public anchor" id="var-replace-with"><h3>replace-with</h3><div class="usage"><code>(replace-with e-doc)</code></div><div class="doc"><pre class="plaintext">$replaceRoot
Alias of replace-root</pre></div></div><div class="public anchor" id="var-sample"><h3>sample</h3><div class="usage"><code>(sample number)</code></div><div class="doc"><pre class="plaintext">Usefull for very big collections
if sample=first stage in pipeline
          number&lt;5% collection size
          collection&gt;100 documents
i will get number random documents
else random sort,full collection scan,and select number documents</pre></div></div><div class="public anchor" id="var-set-s"><h3>set-s</h3><div class="usage"><code>(set-s &amp; fields)</code></div><div class="doc"><pre class="plaintext">$set
Set is an alias of add,used in update
Like add-fields set is not used,map literas means add-fields</pre></div></div><div class="public anchor" id="var-skip"><h3>skip</h3><div class="usage"><code>(skip n)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-sort"><h3>sort</h3><div class="usage"><code>(sort &amp; fields)</code></div><div class="doc"><pre class="plaintext">$sort
Call
(sort- :a :!b)</pre></div></div><div class="public anchor" id="var-union-s"><h3>union-s</h3><div class="usage"><code>(union-s coll-name &amp; stages)</code></div><div class="doc"><pre class="plaintext">$unionWith
Reads from the collection and add documents in the pipeline
no processing is made,duplicates can be added also</pre></div></div><div class="public anchor" id="var-unset"><h3>unset</h3><div class="usage"><code>(unset &amp; fields)</code></div><div class="doc"><pre class="plaintext">like project using only :!field
not useful, :! is better and only project</pre></div></div><div class="public anchor" id="var-unwind"><h3>unwind</h3><div class="usage"><code>(unwind field-reference &amp; options)</code></div><div class="doc"><pre class="plaintext">$unwind
1 document with array of n documents becomes
those n documents are like the old 1 document
with one extra field with the array member
Example
{ :field1  value1 :field2 [1 2]}
-&gt;
{ :field1  value1  :field2 1}
{ :field1  value2  :field2 2}
Normally  1 document with an array of N members =&gt; N documents
Options
 Include one field to keep the index the member had in the
 initial array (default no index)
 {:includeArrayIndex  string}

 Used in special case2 (default false)
 {:preserveNullAndEmptyArrays true/false}
Array field special cases
 unwind to itself(1 document)
 (if i used includeArrayIndex,the index will have value null)
 1)a single value(not array,not null) =&gt;
 Dissapear if {:preserveNullAndEmptyArrays: false}(default)
 unwind to itself(1 document) if {:preserveNullAndEmptyArrays: true}
 2)null/empty array/missing field</pre></div></div><div class="public anchor" id="var-unwind-add-to-root"><h3>unwind-add-to-root</h3><div class="usage"><code>(unwind-add-to-root doc-e)</code></div><div class="doc"><pre class="plaintext">newRoot=doc+member
1 array with n members =&gt; n documents added to root
Keeps the unwinded field also
{'a' 'b'
 :myarray [doc1 doc2]}
Replaced from the 2 docs
{'a' 'b' :myarray doc1}
{'a' 'b' :myarray doc2}</pre></div></div><div class="public anchor" id="var-unwind-move-to-root"><h3>unwind-move-to-root</h3><div class="usage"><code>(unwind-move-to-root doc-e)</code></div><div class="doc"><pre class="plaintext">newRoot=doc+member_fields
1 array with n members =&gt; n documents added to root
Keeps the unwinded field also
{'a' 'b'
 :myarray [doc1 doc2]}
Replaced from the 2 docs,like doc moved to root
(merge {'a' 'b'} doc1)
(merge {'a' 'b'} doc2)</pre></div></div><div class="public anchor" id="var-unwind-replace-root"><h3>unwind-replace-root</h3><div class="usage"><code>(unwind-replace-root doc-e)</code></div><div class="doc"><pre class="plaintext">newRoot=doc-member
1 array with n members =&gt; n documents as roots
Like replace collection with the array members
{:a 'b'
 :myarray [doc1 doc2]}
Replaces from the 2 docs
doc1
doc2</pre></div></div></div></body></html>