(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{112:function(e,a,t){"use strict";t.d(a,"a",(function(){return b})),t.d(a,"b",(function(){return d}));var n=t(0),r=t.n(n);function l(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){l(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function s(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=r.a.createContext({}),u=function(e){var a=r.a.useContext(c),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},b=function(e){var a=u(e.components);return r.a.createElement(c.Provider,{value:a},e.children)},p={inlineCode:"code",wrapper:function(e){var a=e.children;return r.a.createElement(r.a.Fragment,{},a)}},m=r.a.forwardRef((function(e,a){var t=e.components,n=e.mdxType,l=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),b=u(t),m=n,d=b["".concat(o,".").concat(m)]||b[m]||p[m]||l;return t?r.a.createElement(d,i(i({ref:a},c),{},{components:t})):r.a.createElement(d,i({ref:a},c))}));function d(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var l=t.length,o=new Array(l);o[0]=m;var i={};for(var s in a)hasOwnProperty.call(a,s)&&(i[s]=a[s]);i.originalType=e,i.mdxType="string"==typeof e?e:n,o[1]=i;for(var c=2;c<l;c++)o[c]=t[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},113:function(e,a,t){"use strict";function n(e){var a,t,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(a=0;a<e.length;a++)e[a]&&(t=n(e[a]))&&(r&&(r+=" "),r+=t);else for(a in e)e[a]&&(r&&(r+=" "),r+=a);return r}a.a=function(){for(var e,a,t=0,r="";t<arguments.length;)(e=arguments[t++])&&(a=n(e))&&(r&&(r+=" "),r+=a);return r}},117:function(e,a,t){"use strict";var n=t(0),r=t(118);a.a=function(){const e=Object(n.useContext)(r.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},118:function(e,a,t){"use strict";var n=t(0);const r=Object(n.createContext)(void 0);a.a=r},119:function(e,a,t){"use strict";var n=t(0),r=t.n(n),l=t(117),o=t(113),i=t(48),s=t.n(i);const c=37,u=39;a.a=function(e){const{block:a,children:t,defaultValue:i,values:b,groupId:p,className:m}=e,{tabGroupChoices:d,setTabGroupChoices:h}=Object(l.a)(),[g,f]=Object(n.useState)(i),[j,O]=Object(n.useState)(!1);if(null!=p){const e=d[p];null!=e&&e!==g&&b.some((a=>a.value===e))&&f(e)}const y=e=>{f(e),null!=p&&h(p,e)},w=[],v=e=>{e.metaKey||e.altKey||e.ctrlKey||O(!0)},N=()=>{O(!1)};return Object(n.useEffect)((()=>(window.addEventListener("keydown",v),window.addEventListener("mousedown",N),()=>{window.removeEventListener("keydown",v),window.removeEventListener("mousedown",N)})),[]),r.a.createElement("div",null,r.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(o.a)("tabs",{"tabs--block":a},m)},b.map((e=>{let{value:a,label:t}=e;return r.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":g===a,className:Object(o.a)("tabs__item",s.a.tabItem,{"tabs__item--active":g===a}),style:j?{}:{outline:"none"},key:a,ref:e=>w.push(e),onKeyDown:e=>{((e,a,t)=>{switch(t.keyCode){case u:((e,a)=>{const t=e.indexOf(a)+1;e[t]?e[t].focus():e[0].focus()})(e,a);break;case c:((e,a)=>{const t=e.indexOf(a)-1;e[t]?e[t].focus():e[e.length-1].focus()})(e,a)}})(w,e.target,e),v(e)},onFocus:()=>y(a),onClick:()=>{y(a),O(!1)},onPointerDown:()=>O(!1)},t)}))),r.a.createElement("div",{role:"tabpanel",className:"margin-vert--md"},n.Children.toArray(t).filter((e=>e.props.value===g))[0]))}},120:function(e,a,t){"use strict";var n=t(0),r=t.n(n);a.a=function(e){return r.a.createElement("div",null,e.children)}},77:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return c})),t.d(a,"metadata",(function(){return u})),t.d(a,"rightToc",(function(){return b})),t.d(a,"default",(function(){return m}));var n=t(2),r=t(6),l=(t(0),t(112)),o=t(119),i=t(120),s=["components"],c={id:"why",title:" ",sidebar_label:"Why cMQL?",slug:"/intro/why"},u={unversionedId:"intro/why",id:"intro/why",isDocsHomePage:!1,title:" ",description:"Why cMQL",source:"@site/docs/intro/why.md",slug:"/intro/why",permalink:"/cmql-core/docs/intro/why",version:"current",sidebar_label:"Why cMQL?",sidebar:"someSidebar",previous:{title:" ",permalink:"/cmql-core/docs/"},next:{title:" ",permalink:"/cmql-core/docs/cMQL/intro"}},b=[{value:"Why cMQL",id:"why-cmql",children:[]},{value:"Quering,Data processing",id:"queringdata-processing",children:[{value:"Data software",id:"data-software",children:[]},{value:"Functional programming",id:"functional-programming",children:[]},{value:"Data processing",id:"data-processing",children:[]}]},{value:"Pipelines",id:"pipelines",children:[{value:"1 data source",id:"1-data-source",children:[]},{value:"Many data sources",id:"many-data-sources",children:[]},{value:"Nested syntax",id:"nested-syntax",children:[]}]},{value:"Clojure",id:"clojure",children:[{value:"Functional and homoiconic",id:"functional-and-homoiconic",children:[]},{value:"MQL similarities",id:"mql-similarities",children:[]},{value:"JSON like literals",id:"json-like-literals",children:[]},{value:"Macros",id:"macros",children:[]},{value:"Keywords",id:"keywords",children:[]},{value:"Simple and practical",id:"simple-and-practical",children:[]},{value:"Run in many Drivers",id:"run-in-many-drivers",children:[]}]},{value:"Comparison",id:"comparison",children:[{value:"Java",id:"java",children:[]},{value:"Mongoose",id:"mongoose",children:[]},{value:"Spring Data MongoDB",id:"spring-data-mongodb",children:[]}]}],p={rightToc:b};function m(e){var a=e.components,t=Object(r.a)(e,s);return Object(l.b)("wrapper",Object(n.a)({},p,t,{components:a,mdxType:"MDXLayout"}),Object(l.b)("h2",{id:"why-cmql"},"Why cMQL"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"less code up to ",Object(l.b)("strong",{parentName:"li"},"3x")),Object(l.b)("li",{parentName:"ul"},"clear structure  "),Object(l.b)("li",{parentName:"ul"},"clear notation  ")),Object(l.b)("p",null,"For the 3 basic reasons see ",Object(l.b)("a",{parentName:"p",href:"/docs/cmqltool/cmqltool"},"what is cMQL")," and the examples on ",Object(l.b)("a",{parentName:"p",href:"www.cmql-live.org"},"cMQL-live"),"    "),Object(l.b)("p",null,"The other 3 reasons are that cMQL is"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"good choice for querying/data processing in general  "),Object(l.b)("li",{parentName:"ul"},"like MQL with (), both are functional homoiconic   "),Object(l.b)("li",{parentName:"ul"},"simple,provides easy interop and portable queries because it uses Clojure features")),Object(l.b)("p",null,"Here we will focus on those 3 reasons "),Object(l.b)("h2",{id:"queringdata-processing"},"Quering,Data processing"),Object(l.b)("h3",{id:"data-software"},"Data software"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"MongoDB choosed MQL , a functional ",Object(l.b)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Homoiconicity"},"homoiconic"),"  language",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"https://docs.mongodb.com/manual/reference/command/"},"Commands")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"https://docs.mongodb.com/manual/reference/operator/"},"Query operators"),Object(l.b)("br",{parentName:"li"}),"MQL is not a general programming language, it is missing feautures, but looks like functional programming.     "))),Object(l.b)("li",{parentName:"ul"},"Apache Hadoop is based on map reduce that comes from functional programming  "),Object(l.b)("li",{parentName:"ul"},"Apache Spark is made in Scala  "),Object(l.b)("li",{parentName:"ul"},"Apache Kafka is made in Java,Scala  "),Object(l.b)("li",{parentName:"ul"},"RethinkDB chose ",Object(l.b)("a",{parentName:"li",href:"https://rethinkdb.com/docs/introduction-to-reql/#reql-queries-are-functional"},"ReQL")," to be functional  ")),Object(l.b)("p",null,"The reason is because data processing using pipelines is a form of functional programming.",Object(l.b)("br",{parentName:"p"}),"\n","Also functional programming avoids mutable state,making parallel data processing easier.     "),Object(l.b)("h3",{id:"functional-programming"},"Functional programming"),Object(l.b)("p",null,"Functional programming"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"we use a series of nested calls,instead of making a series of assignments\n(we use constants,the result of a function doesn't update the state of a variable,it goes to the next function as argument)"),Object(l.b)("li",{parentName:"ul"},"we have independed functions that we use as arguments, or we return functions  ")),Object(l.b)("p",null,"*we can have mutable state and we can have names to hold a value,but the above are the main way of functional programming.    "),Object(l.b)("h3",{id:"data-processing"},"Data processing"),Object(l.b)("p",null,"Data processing can be seen as a form of functional programming   "),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"we use nested calls for pipelines (data goes from one function to the next)  "),Object(l.b)("li",{parentName:"ul"},"we have independed functions that we use as arguments to define the trasformations\n(functions as arguments,for example map/filter/reduce etc)")),Object(l.b)("p",null,"On data processing,we focus on returning data,and less on returning functions.  "),Object(l.b)("h2",{id:"pipelines"},"Pipelines"),Object(l.b)("p",null,"In data processing commonly use 2 types of pipelines     "),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"1 data source (like aggregation stages)",Object(l.b)("br",{parentName:"li"}),"(function takes as input the output of 1 function only)"),Object(l.b)("li",{parentName:"ul"},"many data sources (like aggregation operators)",Object(l.b)("br",{parentName:"li"}),"(function takes as input the output of many functions,arguments that are function calls)")),Object(l.b)("p",null,"Pipeline programming is ",Object(l.b)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Pipeline_(software)#Other_considerations"},"a form of functional programming."),Object(l.b)("br",{parentName:"p"}),"\n","The ",Object(l.b)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Pipeline_(software)"},"output of a function become input to the next function."),"   "),Object(l.b)("h3",{id:"1-data-source"},"1 data source"),Object(l.b)("p",null,"One data source like aggregation stages in MQL\nEach function, has max 1 function call as argument,and possible more\narguments that are not function calls.  "),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},"(f3 (f2 (f1 arg1)\n        arg2\n        arg3)\n    arg4)\n")),Object(l.b)("p",null,'Because the tree is almost like a line(extra arguments are just leaves,not trees),\nwe can use a "trick" and make the nested calls to look like a line.   '),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},"   data -> f1 -> f2 ->f3 ....-> final_data\n\n   (-> (f1 data) f2 f3 ...)                        ;;clojure \n\n   tranform(f1).transform(f2).transform(f3)...     ;;Java8+,we need lambdas   \n")),Object(l.b)("p",null,"This allows us to avoid the nested calls,for the simple case that we have max 1\nfunction call as argument.   "),Object(l.b)("h3",{id:"many-data-sources"},"Many data sources"),Object(l.b)("p",null,"Many data sources like aggregate operators.",Object(l.b)("br",{parentName:"p"}),"\n","A function that can take inputs that are results of other function calls.  "),Object(l.b)("p",null,"The above trick cannot work here,or even if we try to make a tree look like a line,\nit would so hard to understand what it does(we would have to imagine the tree structure).   "),Object(l.b)("h3",{id:"nested-syntax"},"Nested syntax"),Object(l.b)("p",null,"When we nest code,we need the programming language syntax,to make it readable for us.   "),Object(l.b)("p",null,"How we nest things?",Object(l.b)("br",{parentName:"p"}),"\n","We start with a symbol that symbolize the nesting level,and inside it we put the code      "),Object(l.b)("h4",{id:"example"},"Example"),Object(l.b)(o.a,{defaultValue:"{.",values:[{label:"{.",value:"{."},{label:".{",value:".{"},{label:".(",value:".("},{label:"(.",value:"(."}],mdxType:"Tabs"},Object(l.b)(i.a,{value:"{.",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},"{\n  st1\n  st2\n  {\n    st3\n    st4\n    {\n       st5\n       st6\n    }\n  }\n}\n\nwhere => read { special symbol     (find nested level)\nwhat  => read inside what it does  (find what the code does)\n\nWe also need to check more outer or more inner levels to get the whole picture  \n"))),Object(l.b)(i.a,{value:".{",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},"Having the first statement out of the block,doesn't make sense    \n\nst1\n{\n  st2\n  st3\n  {\n    st4\n    st5\n    {\n      st6\n    }\n  }      \n}\n\nwhere => read st3 not special symbol,read { special symbol\nwhat  => go back to read st3,read inside for the rest\n\nWe also need to check more outer or more inner levels to get the whole picture  \n"))),Object(l.b)(i.a,{value:".(",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},"f1 (f2\n    f3 (f5 (f6 f7)\n        f4))))\n\nThe same replacing { with ( as nesting level special symbol    \nIt doesn't make sense having the function name out,makes nested code un-readable  \n\nHow fast we can find the function calls (the levels)    \nEven in 3 lines its confusing   \n"))),Object(l.b)(i.a,{value:"(.",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},"(f1 f2\n    (f3 (f5 f6 f7)\n        f4)))\n\nVery fast to know that the function calls are f5,f3,f1 (the levels)   \nFind the ( and read the function names    \n\nStarting the function call with ( helpes on nested code  \n"))),Object(l.b)("p",null,"The above nested call was only 3 lines example,and still it became clear\ni think,why nesting symbol at the start is important.  "),Object(l.b)("p",null,"In real complex multiline code,not having a symbol to find the nested level,\nmakes the code almost impossible to write and read.  ")),Object(l.b)("h4",{id:"query-example"},"Query example"),Object(l.b)("p",null,'we know that "takis" employer of dept 1,has a new child {:name "elpida" :age 2}\nand we want to add it.    '),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},'(insert :testdb.testcoll\n        {:dept 1\n         :employers [{:id 1\n                      :name "takis"\n                      :children [{:name "nikos"\n                                  :age 5}\n                                 {:name "helen"\n                                  :age 8}]}]})\n')),Object(l.b)(o.a,{defaultValue:"cMQL assoc-in",values:[{label:"(. cMQL",value:"(."},{label:".(",value:".("},{label:"cMQL assoc-in",value:"cMQL assoc-in"}],mdxType:"Tabs"},Object(l.b)(i.a,{value:"(.",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},'(update- :testdb.testcoll\n  (uq (= :dept 1)\n      (replace-root\n        (merge\n          :ROOT.\n          {:employers\n           (map\n             (fn [:employer.]\n               (if- (= :employer.name. "takis")\n                    (merge :employer.\n                           {:children (conj :employer.children.\n                                            {:name "elpida"\n                                             :age 2})})\n                    :employer.))\n             :employers)}))))\n'))),Object(l.b)(i.a,{value:".(",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},'update-(:testdb.testcoll,\n  uq(dept = 1,\n     replace-root(\n       merge(\n         :ROOT.,\n         {:employers \n          map(\n            fn(:employer.)\n            {\n              if(:employer.name. = "takis")\n                merge(:employer.,\n                      {:children conj(:employer.children.,\n                                      {:name "elpida"\n                                       :age 2})})\n               :employer.\n            }\n            :employers)}))))\n\nThe above is an attempt to write the same code,only with nesting symbol\nafter the function name   \nIf we forget its nested code it might seem readable,but when we see that\nits nested calls,it becames un-readable      \n'))),Object(l.b)(i.a,{value:"cMQL assoc-in",mdxType:"TabItem"},Object(l.b)("p",null,"cMQL has an operator to make easy read/update nested documents/arrays easy  "),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},'(update- :testdb.testcoll\n         (uq (= :dept 1)\n             (replace-root (assoc-in :ROOT. ["employers"\n                                             {:icond (= :v.name. "takis")}\n                                             "children"\n                                             {:icond (count :a.)}]\n                                     {:name "elpida"\n                                     :age 2}))))\n\nIt means\n- get key employers   \n- get index X , where the element(:v.) in position X has (:v.name. "takis")   \n- get key "children"    \n- get index X , where it equals with the end of the array \n  (we want to add in end of unknow size array)   \n\nThey are very easy to use, for more see Collections/Nested  \n')))),Object(l.b)("h4",{id:"mql"},"MQL"),Object(l.b)("p",null,"MQL is nested language(aggregate operators can take many arguments,we cant just put them in line like stages),\ndata processing is nested programming, so we will be nesting code anyways, and this is where cMQL can help.    "),Object(l.b)("h2",{id:"clojure"},"Clojure"),Object(l.b)("p",null,"Reasons for selecting Clojure for cMQL   "),Object(l.b)("p",null,"The above was about why functional programming helps on data processing",Object(l.b)("br",{parentName:"p"}),"\n","The bellow are how Clojure's features and similarities with MQL helped on making cMQL    "),Object(l.b)("h3",{id:"functional-and-homoiconic"},"Functional and homoiconic"),Object(l.b)("p",null,"For the reasons above, functional programming supports data processing.  "),Object(l.b)("p",null,"Homoiconic"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"means that the code is written in language data structures.  "),Object(l.b)("li",{parentName:"ul"},"homoiconic languages have very simple syntax\n(code in clojure is lists and vectors,code in MQL is maps and arrays)"),Object(l.b)("li",{parentName:"ul"},"we can do meta programming with them,process code,to generate code",Object(l.b)("br",{parentName:"li"}),"(see bellow macros)    "),Object(l.b)("li",{parentName:"ul"},"MQL is homoiconic also,so it looked natural fit (see below)  ")),Object(l.b)("h3",{id:"mql-similarities"},"MQL similarities"),Object(l.b)("p",null,"Both are functional and homoiconic (code is written in language data structures)",Object(l.b)("br",{parentName:"p"}),"\n","Both are also made to be easy to use them with other languages.    "),Object(l.b)("p",null,"The programming style is exactly the same, and Clojure experience can be used in MQL,\nor the opposite, if someone likes MQL its very likely to like Clojure also.  "),Object(l.b)("p",null,"MQL looks like Clojure in {}\nMQL uses {f-name ...} Clojure uses (f-name ...)"),Object(l.b)("p",null,"MQL"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},"{'$setIntersection' : ['$w' ,'$z']}\n")),Object(l.b)("p",null,"cMQL"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},"(intersection :w :z)\n")),Object(l.b)("p",null,"cMQL wraps MQL without changing the programming style.  "),Object(l.b)("h3",{id:"json-like-literals"},"JSON like literals"),Object(l.b)("p",null,"In Clojure we have clojure-maps,we can use them to represent data,that we will insert.  "),Object(l.b)("p",null,"Clojure has many data structures like lists/vectors/sets/maps.  "),Object(l.b)("p",null,"We can write cMQL queries but whenever we want we can use raw MQL also inside the\ncMQL queries"),Object(l.b)("p",null,"For example we could write even very mixed code like the bellow,stage operator in MQL,reference in cMQL,\none aggregate operator in cMQL the other in MQL.  "),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},'(q acoll\n   {"$addfields" {:a (+ 1 {"$add" [2 3]})}})\n')),Object(l.b)("h3",{id:"macros"},"Macros"),Object(l.b)("p",null,"Clojure has powerful macros,as a homoiconic language we are allowed to write code\nthat will generate code.Macros run before running the clojure code,and they produce\nthe final source code.   "),Object(l.b)("p",null,'Macros are very important on making "new languages".',Object(l.b)("br",{parentName:"p"}),"\n","This way the user can write much less code,or can write even invalid Clojure code,\nthat the macro will process to produce the valid Clojure code.  "),Object(l.b)("p",null,"With macros,we are free to make the new language as we wanted to be.\nFor example macros allowed as to use language core names like reduce/map/let etc.  "),Object(l.b)("p",null,"In cMQL we do "),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},"(map (fn [:m.] (* (+ :m. 1) 2)) :myarray)\n")),Object(l.b)("p",null,"Not"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},"(m-map (m-fn [:m.] (mul (add :m. 1)) :myarray))\n")),Object(l.b)("h3",{id:"keywords"},"Keywords"),Object(l.b)("p",null,"In clojure we have keywords.\nHere we use them for fields and variables.  "),Object(l.b)("p",null,":myfield = field reference\n:myvar.  = a var (has a . in the end or in start like  :.myvar)"),Object(l.b)("p",null,'This allowed us to not use the "$$" "$" that is hard to read.  '),Object(l.b)("h3",{id:"simple-and-practical"},"Simple and practical"),Object(l.b)("p",null,"It allowed us to remove MQL verbosity,without inventing a new language.",Object(l.b)("br",{parentName:"p"}),"\n","The simple Clojure's way was used.    "),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},"  (reduce (fn [sum n] (+ sum n)) [] myarray)               ; clojure\n")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},"  (reduce (fn [:sum. :n.] (+ :sum. :n.)) [] :myarray)      ; cMQL\n")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},'  {"$reduce" {"input" "$myarray",                          ; MQL\n              "initialValue" [],\n              "in" {"$let" {"vars" {"sum" "$$value", "n" "$$this"},\n                            "in" {"$add" ["$$sum" "$$n"]}}}}}\n')),Object(l.b)("h3",{id:"run-in-many-drivers"},"Run in many Drivers"),Object(l.b)("p",null,"Clojure is made to be a hosted language,it doesn't just runs in JVM for example,\nClojure is made for the JVM,and Clojurescript is made for Javascript.  "),Object(l.b)("p",null,"We also have many Clojure's,cMQL works only for java/js for now.",Object(l.b)("br",{parentName:"p"}),"\n","This allows us easy interop,and portable cMQL queries between the drivers cMQL supports .  "),Object(l.b)("h2",{id:"comparison"},"Comparison"),Object(l.b)("p",null,"cMQL uses clojure features and the similarities with MQL to make the query builder simple.  "),Object(l.b)("p",null,"If java or javascript was used to make the query builder  "),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"not functional, not natural for querying and data processing       "),Object(l.b)("li",{parentName:"ul"},"not readable nesting of function calls    "),Object(l.b)("li",{parentName:"ul"},"not like MQL different syntax, programming model     "),Object(l.b)("li",{parentName:"ul"},"no JSON literals   "),Object(l.b)("li",{parentName:"ul"},"no macros,to make the query builder less verbose     "),Object(l.b)("li",{parentName:"ul"},"no keywords,to use for the fields     "),Object(l.b)("li",{parentName:"ul"},"queries would run only in java or only in javascript   ")),Object(l.b)("p",null,"The result would be a verbose,not portable query builder,not suitable for data processing",Object(l.b)("br",{parentName:"p"}),"\n","That would be also harder to make.   "),Object(l.b)("p",null,"Query builders that we have can be very incomplete also.   "),Object(l.b)("p",null,"Queries bellow are so simple and so small like 5 lines,cMQL goes ~2x even in simple queries,",Object(l.b)("br",{parentName:"p"}),"\n",'but cMQL is not just a way to make easy queries very easy,for big or complex queries,\nit is a way to avoid "code explosion" see also ',Object(l.b)("a",{parentName:"p",href:"/docs/#example-3"},"example3")," ",Object(l.b)("a",{parentName:"p",href:"/docs/#example-4"},"example4"),"       "),Object(l.b)("h3",{id:"java"},"Java"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Java Mongodb official driver",Object(l.b)("br",{parentName:"li"}),"doesn't cover most aggregate operators(only stages/filters(some query operators)/accumulators)",Object(l.b)("br",{parentName:"li"}),"We have like 100+ aggregate operators more that we have to write MQL to use them",Object(l.b)("br",{parentName:"li"}),"(there is no let/map/reduce/filter etc)       "),Object(l.b)("li",{parentName:"ul"},"java is not like MQL making a java query builder is harder  ")),Object(l.b)("p",null,"Small example in Java only with covered operators (if not covered we could go 4x+)"),Object(l.b)("p",null,"cMQL = 79 characters",Object(l.b)("br",{parentName:"p"}),"\n","Java Query = 188 characters (~2x)    "),Object(l.b)(o.a,{defaultValue:"cMQL",values:[{label:"cMQL",value:"cMQL"},{label:"Java Query Builder",value:"Java Query Builder"}],mdxType:"Tabs"},Object(l.b)(i.a,{value:"cMQL",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},'(q zips\n   (= :state "TX")\n   (group :city {:totalPop :pop}\n   [:!_id :totalPop]\n   (sort :!totalPop)))\n'))),Object(l.b)(i.a,{value:"Java Query Builder",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},'   zips.aggregate(\n      asList(\n        match(eq("state", "TX")),\n        group("$city", sum("totalPop", "$pop")),\n        project(fields(excludeId(), include("totalPop"), computed("city", "$_id"))),\n        sort(descending("totalPop"))));\n')))),Object(l.b)("h3",{id:"mongoose"},"Mongoose"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Mongoose supports JSON like literals,and and raw MQL is generaly used."),Object(l.b)("li",{parentName:"ul"},"Query builder offers even less than the Java one.  "),Object(l.b)("li",{parentName:"ul"},"The result is a mix of MQL with the query builder.  ")),Object(l.b)("p",null,"It has the problems of MQL ",Object(l.b)("a",{parentName:"p",href:"/docs/"},"for more see the examples")),Object(l.b)("h3",{id:"spring-data-mongodb"},"Spring Data MongoDB"),Object(l.b)("p",null,Object(l.b)("a",{parentName:"p",href:"https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/#reference"},"Spring data MongoDB")," query builder offers\naggregator operators.   "),Object(l.b)("p",null,"cMQL = 92 characters",Object(l.b)("br",{parentName:"p"}),"\n","Spring = 180 characters (2x)  "),Object(l.b)(o.a,{defaultValue:"cMQL",values:[{label:"cMQL",value:"cMQL"},{label:"Spring Query Builder",value:"Spring Query Builder"}],mdxType:"Tabs"},Object(l.b)(i.a,{value:"cMQL",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},'(q coll\n   [:firstname\n    :lastname\n    {:created (map (fn [:u.] (str :u.firstname. " " :u.lastname.)) :created)}])\n'))),Object(l.b)(i.a,{value:"Spring Query Builder",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-text"},'aggregate(\n  newAggregation(\n    project("firstname","lastname")\n    .and(itemsOf("created").as("u").andApply(\n         valueOf("$$u.firstName").concat(" ").concatValueOf("$$u.lastname")))\n    .as("created")));\n')))),Object(l.b)("p",null,"Even in so small example we can see many of the problems described above  "),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"map is not clear"),Object(l.b)("li",{parentName:"ul"},"the function that we will use is not clear the body and the arguments"),Object(l.b)("li",{parentName:"ul"},"the nesting is not clear"),Object(l.b)("li",{parentName:"ul"},"we have extra words like and/as/valueOf/concatValueOf/andApply,"),Object(l.b)("li",{parentName:"ul"},'we also have a mixed notation of references and variables with "$$","$"   ')),Object(l.b)("p",null,"And its not Spring query builder problem,the problem is that we dont have macros,\nto make a nice query builder, and we try to wrap MQL(functional homoiconic) with\na procedural language,and then write functional code with it.    "))}m.isMDXComponent=!0}}]);